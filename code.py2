import board
import digitalio
import time
import touchio  # for capacitive touch sensor
from adafruit_debouncer import Debouncer  # for capacitive touch sensor
import neopixel  # for neopixel output
from os import getenv  # for wifi
import adafruit_requests
import wifi
import ipaddress  # for wifi
import adafruit_connection_manager
import adafruit_minimqtt.adafruit_minimqtt as MQTT
from adafruit_io.adafruit_io import IO_MQTT
from rainbowio import colorwheel
import simpleio
from adafruit_led_animation.animation.pulse import Pulse

wifi_ssid = getenv("CIRCUITPY_WIFI_SSID")
wifi_password = getenv("CIRCUITPY_WIFI_PASSWORD")
aio_username = getenv("ADAFRUIT_AIO_USERNAME")
aio_key = getenv("ADAFRUIT_AIO_KEY")

radio = wifi.radio
while not radio.connected:
    radio.connect(wifi_ssid, wifi_password)

# get the pool and ssl_context from the helpers:
pool = adafruit_connection_manager.get_radio_socketpool(radio)
ssl_context = adafruit_connection_manager.get_radio_ssl_context(radio)

# request session
requests = adafruit_requests.Session(pool, ssl_context)
connection_manager = adafruit_connection_manager.get_connection_manager(pool)

print("My MAC addr:", [hex(i) for i in wifi.radio.mac_address])

#  prints IP address to REPL
print(f"My IP address is {wifi.radio.ipv4_address}")

#  pings Google
ipv4 = ipaddress.ip_address("8.8.4.4")
print("Ping google.com: %f ms" % (wifi.radio.ping(ipv4) * 1000))

# MQTT Setup ###

mqtt_TX = f"{aio_username}/feeds/cc0"
mqtt_RX = f"{aio_username}/feeds/cc1"

# Define callback methods which are called when events occur
def connected(client):
    # This function will be called when the mqtt_client is connected
    # successfully to the broker.
    print("Connected to AdafruitIO!")
    client.subscribe("cc1")

def subscribe(client, userdata, topic, granted_qos):
    # This method is called when the mqtt_client subscribes to a new feed.
    print(f"Subscribed to {topic}")


def publish(client, userdata, topic, pid):
    # This method is called when the mqtt_client publishes data to a feed.
    print(f"Published to {topic}")


def message(client, feedid, msg):
    print(f"New message from {client} on {feedid}: {msg}")
    if msg == "here":
        pixels.fill(ROSE)
        pixels.brightness = .9
        pixels.show()
        still_alive1()
        for i in range(10):
            touch_deb.update()
            if touch_deb.rose:
                io.publish('cc0', 'together')
                pixels.fill(LIGHTRED)
                pixels.show()
                still_alive2()
                lightcycle()
            else:
                time.sleep(.5)
    elif msg == "together":
        lightcycle()
    elif msg == "off":
        return 'off'
    else:
        print(f"Unexpected message on {feedid} feed.")

# Set up a MiniMQTT Client
mqtt_client = MQTT.MQTT(
    broker="io.adafruit.com",
    port=1883,
    username=aio_username,
    password=aio_key,
    socket_pool=pool,
    ssl_context=ssl_context,
    )

io = IO_MQTT(mqtt_client)

# Connect callback handlers to mqtt_client
io.on_connect = connected
io.on_subscribe = subscribe
io.on_publish = publish
io.on_message = message

print(f"Attempting to connect to {mqtt_client.broker}")
io.connect()

print(f"Publishing to {mqtt_TX}")
io.publish('cc0', 'off')

# LIGHTS
pixel_pin = board.GP6
num_pixels = 8
speed = .05
pixels = neopixel.NeoPixel(
    pixel_pin, num_pixels, brightness=0.1, auto_write=False, pixel_order=(1, 0, 2, 3)
)

def rainbow_cycle(wait):
    for color in range(255):
        for pixel in range(num_pixels):
            pixel_index = (pixel * 256 // num_pixels) + color
            pixels[pixel] = colorwheel(pixel_index & 255)
        pixels.show()
        time.sleep(wait)

def lightcycle():
    pixels.brightness = .5
    pixels.fill(ROSE)
    pixels.show()
    time.sleep(.5)
    pixels.fill(PURPLE)
    pixels.show()
    time.sleep(.5)
    pixels.fill(IRIS)
    pixels.show()
    time.sleep(.5)
    pixels.fill(MAGENTA)
    pixels.show()
    time.sleep(.5)
    pixels.fill(PINK)
    pixels.show()
    time.sleep(.5)
    pixels.fill(FUSCHIA)
    pixels.show()
    time.sleep(.5)
    pixels.fill(CORAL)
    pixels.show()
    time.sleep(.5)
    pixels.fill(LIGHTRED)
    pixels.show()
    time.sleep(.5)
    pixels.fill(ROSE)
    pixels.show()
    time.sleep(.5)
    pixels.fill(PURPLE)
    pixels.show()
    time.sleep(.5)
    pixels.fill(IRIS)
    pixels.show()
    time.sleep(.5)
    pixels.fill(MAGENTA)
    pixels.show()
    time.sleep(.5)
    pixels.fill(PINK)
    pixels.show()
    time.sleep(.5)
    pixels.fill(FUSCHIA)
    pixels.show()
    time.sleep(.5)
    pixels.fill(CORAL)
    pixels.show()
    time.sleep(.5)
    pixels.fill(LIGHTRED)
    pixels.show()
    time.sleep(.5)

WHITE = (255, 255, 255, 255)
RED = (255, 0, 0, 0)
YELLOW = (255, 150, 0, 0)
GREEN = (0, 255, 0, 0)
CYAN = (0, 255, 255, 0)
BLUE = (0, 0, 255, 0)
PURPLE = (180, 0, 255, 0)
IRIS = (102, 0, 255, 0)
MAGENTA = (153, 0, 255, 0)
PINK = (204, 0, 255, 0)
FUSCHIA = (255, 0, 204, 0)
CORAL = (255, 0, 153, 0)
ROSE = (255, 0, 102, 0)
LIGHTRED = (255, 0, 53, 0)

# SOUND
# Define pin connected to piezo buzzer.
PIEZO_PIN = board.GP2

# Define a list of tones/music notes to play.
TONE_FREQ = [ 440,  # A3
              466,  # A3#
              523,  # C4
              554,  # C4#
              784,  # G5
              740,  # F5#
              660,  # E5
              440,  # A4
              587   # D5
              ]

def still_there():
    simpleio.tone(PIEZO_PIN, TONE_FREQ[0], duration=0.05)
    simpleio.tone(PIEZO_PIN, TONE_FREQ[1], duration=0.4)
    simpleio.tone(PIEZO_PIN, TONE_FREQ[1], duration=0.5)
    simpleio.tone(PIEZO_PIN, TONE_FREQ[2], duration=0.5)
    simpleio.tone(PIEZO_PIN, TONE_FREQ[3], duration=0.7)

def still_alive1():
    simpleio.tone(PIEZO_PIN, TONE_FREQ[4], duration=0.25)
    simpleio.tone(PIEZO_PIN, TONE_FREQ[5], duration=0.25)
    simpleio.tone(PIEZO_PIN, TONE_FREQ[6], duration=0.25)
    simpleio.tone(PIEZO_PIN, TONE_FREQ[6], duration=0.25)
    simpleio.tone(PIEZO_PIN, TONE_FREQ[5], duration=0.5)

def still_alive2():
    simpleio.tone(PIEZO_PIN, TONE_FREQ[7], duration=0.25)
    simpleio.tone(PIEZO_PIN, TONE_FREQ[4], duration=0.25)
    simpleio.tone(PIEZO_PIN, TONE_FREQ[5], duration=0.25)
    simpleio.tone(PIEZO_PIN, TONE_FREQ[6], duration=0.25)
    simpleio.tone(PIEZO_PIN, TONE_FREQ[6], duration=0.25)
    simpleio.tone(PIEZO_PIN, TONE_FREQ[5], duration=0.5)
    time.sleep(.1)
    simpleio.tone(PIEZO_PIN, TONE_FREQ[8], duration=0.5)
    simpleio.tone(PIEZO_PIN, TONE_FREQ[6], duration=0.25)
    simpleio.tone(PIEZO_PIN, TONE_FREQ[7], duration=0.5)

# TOUCHPAD
touch_pad = touchio.TouchIn(board.GP19, digitalio.Pull.UP)
touch_deb = Debouncer(touch_pad)

wait_duration = 10

# main loop
while True:
    # receive messages from MQTT feed
    io.loop()
    # check for touch
    touch_deb.update()
    if touch_deb.rose:  # using rose to sense only when someone touches the lamp.
        io.publish('cc0', 'here')
        pixels.fill(ROSE)
        pixels.brightness = .9
        pixels.show()
        io.loop(5)
        io.publish('cc0', 'off')
    else:
        pixels.fill(WHITE)
        pixels.brightness = .1
        pixels.show()
        time.sleep(.2)
